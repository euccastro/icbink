Make a basic interpreter:
    debugger: enter to repeat last command
    implement ,n (and ,r?)
    BUG: I really need to track source filename in source_pos
    Do Guarded continuations pretty early, because that's where I perceive the biggest risk and complication, and it may be traumatic to retrofit later on
        Test (building everything needed in the process)
        Guarded continuation-based exception handling.

Document rpython branch.

Clean up naming in the various tracing/debugging facilities.

--- Postponed

inherit source positions wherever it makes sense
    YAGNI?

Check out pypy/rpython/rlib/parsing/lexer.py:SourcePos when we want to use source position for debugging and exceptions.
Optimize dictionaries using maps:
    http://morepypy.blogspot.com.es/2011/03/controlling-tracing-of-interpreter-with_21.html
    Maybe we can use some of Pycket's environment optimizations.  Study them while keeping in mind that Kernel has first class environments.
Consider Kernel-compliant handling of cyclic lists.
Consider mutable lists.

--- Archived

start with immutable lists
don't worry about cyclic lists in the beginning
    and maybe don't ever, esp. if I stick to immutable lists
