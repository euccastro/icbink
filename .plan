Error types:
    port debugging
        catch all errors, but don't exit
        debugging executes in a continuation that is a child of the context we stopped in
        the continuation includes guards for kernel-error-cont that just prints the error and continues execution
        now, we don't get the destination continuation, so we can't polymorphically display the error message
            make the throwable irritant contain the information on how to display the error?
                that would simplify error handling, because error continuation would just display the irritant
                so let's have an ErrorDescription class, that we can print out and query for its attributes
                so why not use klisp's?
    test errors
    XXX: source_pos, additional debugging info
    XXX: does the debugger run in the root continuation tree?
    Type error: a builtin expects a type (e.g. string) but gets a different, incompatible one
        This accounts for 100% of the checks in primitive.py!
    Param tree mismatch on definition
        A case of TypeError?
    So, so far we have:
        root-continuation (exits the program)
            error-continuation
                type-error-continuation
                    param-mismatch-continuation
            (user-code-continuation) ; load-continuation?
    REPL root continuation semantics?
        when the interpreter is called in interactive mode, it reads each expression from stdin with a continuation that just prints it out and reads the next one.
    load root continuation semantics?
        when the interpreter is called with a single filename, it reads each expression with a continuation that just reads the next one and discards it, until there are no more expressions to read.
            XXX: do we return the return value of the latest one?  only if it can be coerced to an int?
                in any event, #inert should count as success
    in both cases, these continuations are children of the root continuation
    tasks:
        make a Sequence around all statements?
        make a ReplSequence for the REPL?

Guarded continuation-based exception handling.
    Hierarchy?  See what Klisp has.  Maybe check out R6RS?
        Klisp has error-continuation and system-error-continuation
        Collect all errors we have so far and see whether a hierarchy suggests itself...
        Make all errors recoverable, where it makes sense

Main concepts not done yet:
    Encapsulations
    Static and dynamic keyed variables
    Numbers!

Pilfer tests from SINK and Klisp.
    Maybe when I get closer to claiming feature completeness?

Document non-rpython branch.

More tests for everything, esp. guarded continuations.

--- Postponed

breakpoints in debugger?

inherit source positions wherever it makes sense
    YAGNI?

Optimize dictionaries using maps:
    http://morepypy.blogspot.com.es/2011/03/controlling-tracing-of-interpreter-with_21.html
    Maybe we can use some of Pycket's environment optimizations.  Study them while keeping in mind that Kernel has first class environments.

Consider Kernel-compliant handling of cyclic lists.

Consider mutable lists.

--- Archived

start with immutable lists

story of a combination:
    we interpret a pair
    on interpretation, we evaluate the car, with a CombineCont continuation
    the prev of the CombineCont is the continuation that is expecting the value
        but it doesn't have the right source info because it corresponds to 'upper' in the code
    we may be interested in returning to this place from a continuation where we are
        evaluating the arguments
        evaluating the body of the operative
    CombineCont calls combine on the first arg on plug_reduce *and its own prev expression as the prev*.
        THEREFORE, THE COMBINECONT ITSELF IS NOT REACHABLE ANYMORE!
        The combiner of a primitive operative is not very interesting; just calls primitive code
        The combiner of a compound operative builds the right environment and calls `sequence` (again, on the continuation previous to the combinecont)
        The combiner of an applicative calls evaluate_arguments with an ApplyCont child of the prev.
            def evaluate_arguments(vals, env, cont):
                if isinstance(vals, Pair):
                    return vals.car, env, EvalArgsCont(vals.cdr, env, cont)
                else:
                    return vals, env, cont
            EvalArgsCont, in turn, calls evaluate_arguments with a GatherArgsCont
