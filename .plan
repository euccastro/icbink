Make a basic interpreter:
    implement ,n (and ,r?)
        #XXX: pequeno desfasse: parece que estou mostrando a posiçom errada (o primeiro
              elemento dũa combinaçom, e nom o paréntese.
        tamém tenho que infectar todas as continuations.  Portanto acabava antes metendo o
        código no default e em todas.
        add 'return hook' (and perhaps 'escape hook'?) to kt, so applyCont (combinecont?)
        can trigger it.
        what are ,n and ,r supposed to do on escape?
        XXX: what is ,n supposed to do in a plug_reduce context?
            same as ,r?
                and what does ,r do?
                returns to the closest enclosing application?
                    and how do we intercept there after the fact, without mutating the
                    continuation tree?
                        all plug_reduces have a check for debug?
                            maybe we only need combinator plug_reduces
                                ApplyCont or CombineCont?
                                    Si, potencialmente quero seguir escapando a contextos nos que nunca debuguei in first place.
                quando fazemos um salto nom desativamos debug, apenas instalamos um guard.
                esse guard sabe saltar os contextos nom interessantes.
            well, it can still infect the continuation it's about to return to
                infinite loop?  that's the continuation we infected in first place!
    Do Guarded continuations pretty early, because that's where I perceive the biggest risk and complication, and it may be traumatic to retrofit later on
        Test (building everything needed in the process)
        Guarded continuation-based exception handling.

Document rpython branch.

Clean up naming in the various tracing/debugging facilities.

--- Postponed

inherit source positions wherever it makes sense
    YAGNI?

Check out pypy/rpython/rlib/parsing/lexer.py:SourcePos when we want to use source position for debugging and exceptions.
Optimize dictionaries using maps:
    http://morepypy.blogspot.com.es/2011/03/controlling-tracing-of-interpreter-with_21.html
    Maybe we can use some of Pycket's environment optimizations.  Study them while keeping in mind that Kernel has first class environments.
Consider Kernel-compliant handling of cyclic lists.
Consider mutable lists.

--- Archived

start with immutable lists
don't worry about cyclic lists in the beginning
    and maybe don't ever, esp. if I stick to immutable lists
