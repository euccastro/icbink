big issue: if we give the parser unparsable input, it will just stop and return whatever complete forms it has parsed to that point.  We really need to throw an error.

Error types:
    test errors
    add source_pos, additional debugging info to errors
    debug interaction by default?
        perhaps as a command-line option?
    recover from errors?
        ,c <val> feeds the result back in lieu of what the erroring function would produce?

Guarded continuation-based exception handling.
    Hierarchy?  See what Klisp has.  Maybe check out R6RS?
        Klisp has error-continuation and system-error-continuation
        Collect all errors we have so far and see whether a hierarchy suggests itself...
        Make all errors recoverable, where it makes sense

Main concepts not done yet:
    Numbers!
        just exact integers to start with
            radix
            exactness (ignore, only #e allowed)
            sign
            magnitude
                infinity
                    #e[+-]infinity
                or an unsigned integer in the appropriate radix
            (in that order?)
                no, radix and exactness prefixes may occur in any order
        inexact floats with no bounds info in the future
        check out rlib.
        parse them.
    Encapsulations
    Futures
    Static and dynamic keyed variables

Pilfer tests from SINK and Klisp.
    Maybe when I get closer to claiming feature completeness?

Document non-rpython branch.

More tests for everything, esp. guarded continuations.

--- Postponed

breakpoints in debugger?

inherit source positions wherever it makes sense
    YAGNI?

Optimize dictionaries using maps:
    http://morepypy.blogspot.com.es/2011/03/controlling-tracing-of-interpreter-with_21.html
    Maybe we can use some of Pycket's environment optimizations.  Study them while keeping in mind that Kernel has first class environments.

Consider Kernel-compliant handling of cyclic lists.

Consider mutable lists.

--- Archived

start with immutable lists

story of a combination:
    we interpret a pair
    on interpretation, we evaluate the car, with a CombineCont continuation
    the prev of the CombineCont is the continuation that is expecting the value
        but it doesn't have the right source info because it corresponds to 'upper' in the code
    we may be interested in returning to this place from a continuation where we are
        evaluating the arguments
        evaluating the body of the operative
    CombineCont calls combine on the first arg on plug_reduce *and its own prev expression as the prev*.
        THEREFORE, THE COMBINECONT ITSELF IS NOT REACHABLE ANYMORE!
        The combiner of a primitive operative is not very interesting; just calls primitive code
        The combiner of a compound operative builds the right environment and calls `sequence` (again, on the continuation previous to the combinecont)
        The combiner of an applicative calls evaluate_arguments with an ApplyCont child of the prev.
            def evaluate_arguments(vals, env, cont):
                if isinstance(vals, Pair):
                    return vals.car, env, EvalArgsCont(vals.cdr, env, cont)
                else:
                    return vals, env, cont
            EvalArgsCont, in turn, calls evaluate_arguments with a GatherArgsCont
