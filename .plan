Make a basic interpreter:
    Do Guarded continuations pretty early, because that's where I perceive the biggest risk and complication, and it may be traumatic to retrofit later on
        Start with guard-continuation
            (guard-continuation entry-guards continuation exit-guards) -> inner continuation
            Construct two continuations:
                outer
                    contém entry guards
                inner (return value)
                    contém exit guards
                Ambas guardam tamém o dynamic environment da chamada a guard-continuation
                    vira o entorno para a ativaçom dos entry and exit guards
                normally they just pass their value to the parent.
                    i.e. def plug_reduce(val):
                            return self.prev.plug_reduce(val) 
                
        Guarded continuation-based exception handling.

--- Postponed

Check out pypy/rpython/rlib/parsing/lexer.py:SourcePos when we want to use source position for debugging and exceptions.
Optimize dictionaries using maps:
    http://morepypy.blogspot.com.es/2011/03/controlling-tracing-of-interpreter-with_21.html
    Maybe we can use some of Pycket's environment optimizations.  Study them while keeping in mind that Kernel has first class environments.
Consider Kernel-compliant handling of cyclic lists.
Consider mutable lists.

--- Archived

start with immutable lists
don't worry about cyclic lists in the beginning
    and maybe don't ever, esp. if I stick to immutable lists
